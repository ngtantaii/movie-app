# Cursor Rules for Movie Database Application

## Project Context
This is a React Native movie database application built for a senior React Native position assessment. The app uses TypeScript, Redux Toolkit, React Navigation, and integrates with The Movie Database (TMDB) API.

## Technology Stack
- React Native 0.83.1
- TypeScript
- Redux Toolkit with Redux Persist
- React Navigation (Native Stack + Bottom Tabs)
- Axios for API calls
- AsyncStorage for persistence
- react-native-svg for custom icons

## Code Style & Conventions

### General Rules
- **Language**: All code, comments, and documentation must be in English
- **TypeScript**: Use TypeScript for all new code. Avoid `any` types; use proper interfaces and types
- **Functional Components**: Use functional components with hooks, not class components
- **Naming Conventions**:
  - Components: PascalCase (e.g., `MovieCard.tsx`)
  - Functions/variables: camelCase (e.g., `handleSearch`)
  - Constants: UPPER_SNAKE_CASE (e.g., `API_URL`)
  - Types/Interfaces: PascalCase with `I` prefix (e.g., `IMovie`, `IMovieResponse`)
  - Enums: PascalCase with `E` prefix (e.g., `EMovieCategory`)

### File Organization
- Keep business logic separate from UI components (use custom hooks)
- Place custom hooks in `src/hooks/` or co-located with screens (e.g., `useHomeLogic.ts`)
- API functions in `src/api/`
- Redux slices in `src/store/slices/`
- Reusable components in `src/components/`
- Screen components in `src/screens/[ScreenName]/`

### Component Structure
```typescript
// 1. Imports (React, React Native, third-party, local)
// 2. Types/Interfaces
// 3. Component
// 4. Styles
```

### Code Patterns

#### Custom Hooks Pattern
```typescript
// use[Feature]Logic.ts
export const useFeatureLogic = () => {
  // State
  // Redux hooks
  // API calls
  // Handlers
  // Return object with all needed values/functions
};
```

#### API Functions Pattern
```typescript
// api/[resource].ts
export const resourceApi = {
  getResource: async (id: number) => {
    const response = await apiClient.get<IResource>(`/resource/${id}`);
    return response.data;
  },
};
```

#### Redux Slice Pattern
```typescript
// store/slices/[feature]Slice.ts
const featureSlice = createSlice({
  name: 'feature',
  initialState,
  reducers: {
    // Reducers here
  },
});
```

### TypeScript Guidelines
- Define interfaces for all API responses in `src/api/types.ts`
- Use enums for constants (e.g., `EMovieCategory`)
- Export types from a central types file or co-locate with usage
- Avoid type assertions unless necessary; prefer type guards

### React Native Best Practices
- Use `SafeAreaView` or `SafeAreaProvider` for proper safe area handling
- Use `FlatList` for long lists (not `ScrollView` with `map`)
- Implement proper loading states with `ActivityIndicator`
- Handle error states with user-friendly messages
- Use `TouchableOpacity` or `Pressable` for interactive elements
- Extract styles to `StyleSheet.create()` at the bottom of component files

### State Management
- Use Redux Toolkit for global state (settings, watchlist)
- Use local state (`useState`) for component-specific UI state
- Persist `settings` and `watchlist` slices using Redux Persist
- Access Redux state using typed hooks from `src/store/hooks.ts`

### API Integration
- All API calls go through `src/api/client.ts` (configured Axios instance)
- Use Bearer token authentication (from `.env` file)
- Handle errors in API interceptors and component level
- Use async/await for API calls
- Include proper TypeScript types for all API responses

### Error Handling
- Show user-friendly error messages in UI
- Log errors to console for debugging
- Handle network errors, API errors, and empty data states
- Use try-catch blocks for async operations

### UI/UX Guidelines
- Follow Figma design: https://www.figma.com/file/ZfiD9sNTA9IjlflyipIGmr/App-Developer-Test---UI-Design
- Maintain consistent styling across screens
- Use appropriate colors:
  - Primary: `#01B4E4`
  - Background: `#032541` (for tab bar)
  - Text: Appropriate contrast ratios
- Implement loading states for all async operations
- Show empty states when no data is available
- Use horizontal scroll carousels for cast and recommendations

### Navigation
- Use React Navigation for all navigation
- Bottom tabs for Home and Watchlist screens
- Stack navigation for Home â†’ Details flow
- Use typed navigation (if navigation types are defined)

### Environment Variables
- Never commit `.env` file or API keys
- Use `react-native-dotenv` for environment variables
- Access via `import { API_KEY } from '@env'`

### Git Practices
- Make meaningful commit messages
- Don't commit API keys, `.env` files, or `node_modules`
- Keep repository public for assessment review

### Component Guidelines
- Keep components small and focused (single responsibility)
- Extract reusable UI elements into separate components
- Use props for component configuration
- Prefer composition over inheritance

### Performance
- Use `React.memo` for expensive components if needed
- Implement pagination for movie lists
- Optimize images (use appropriate sizes from TMDB)
- Avoid unnecessary re-renders

### Testing Considerations
- Write testable code (separate logic from UI)
- Use meaningful test descriptions
- Test files should be co-located or in `__tests__/`

### Documentation
- Add JSDoc comments for complex functions
- Document assumptions in code comments
- Keep README updated with setup instructions

## Project-Specific Rules

### Movie Data
- Use TMDB API endpoints as specified in requirements
- Image URLs: `https://image.tmdb.org/t/p/w500{poster_path}`
- Handle null/undefined poster paths gracefully
- Format dates using `date-fns` library

### Watchlist
- Persist watchlist using Redux Persist
- Allow add/remove functionality
- Implement filtering and sorting
- Show remove button (X icon) on each item

### Details Screen
- Display all required movie information
- Show cast members in horizontal carousel
- Optional: Show recommended movies
- Optional: Add to Watchlist button

### Home Screen
- Category dropdown (Now Playing, Upcoming, Popular)
- Search functionality
- Optional: Sort by dropdown
- Persist category and sort preferences

## When Making Changes
1. Follow existing code patterns and structure
2. Maintain TypeScript type safety
3. Update types in `src/api/types.ts` if API structure changes
4. Test on both iOS and Android if possible
5. Ensure error handling is in place
6. Add loading states for async operations
7. Keep UI consistent with existing design

## Common Patterns to Follow

### API Call Pattern
```typescript
const fetchMovies = async () => {
  try {
    setLoading(true);
    const data = await movieApi.getMoviesByCategory(category);
    setMovies(data.results);
  } catch (error) {
    setError('Failed to load movies');
  } finally {
    setLoading(false);
  }
};
```

### Redux Usage Pattern
```typescript
const dispatch = useAppDispatch();
const category = useAppSelector(state => state.settings.selectedCategory);

const handleCategoryChange = (newCategory: EMovieCategory) => {
  dispatch(setSelectedCategory(newCategory));
};
```

### Navigation Pattern
```typescript
const navigation = useNavigation();
const navigateToDetail = (movie: IMovie) => {
  navigation.navigate('Details', { movieId: movie.id });
};
```

## Avoid
- Using `any` type in TypeScript
- Committing API keys or sensitive data
- Using class components
- Mixing business logic directly in components
- Hardcoding values that should be configurable
- Ignoring TypeScript errors
- Creating overly large components
- Not handling error states

